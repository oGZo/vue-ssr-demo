const Koa = require('koa');
const path = require('path');
const fs = require('fs');
const LRU = require('lru-cache');
const serve = require('koa-static');
// const serve = require('koa-serve');
const bodyParser = require('koa-bodyparser');
const { createBundleRenderer } = require('vue-server-renderer');
const app = new Koa();
const port = require('../config').port;
const resolve = file => path.resolve(__dirname, file);
const isProd = process.env.NODE_ENV === 'production';
function createRenderer (bundle, options) {
    // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer
    return createBundleRenderer(bundle, Object.assign(options, {
        // for component caching
        cache: LRU({
        max: 1000,
        maxAge: 1000 * 60 * 15
        }),
        // this is only needed when vue-server-renderer is npm-linked
        basedir: resolve('../dist'),
        // recommended for performance
        runInNewContext: false
    }))
}

let renderer
let readyPromise
const templatePath = resolve('../src/index.template.html')

app.use(bodyParser());


if (isProd) {
    app.use(serve(resolve('../dist')))
    // In production: create server renderer using template and built server bundle.
    // The server bundle is generated by vue-ssr-webpack-plugin.
    const template = fs.readFileSync(templatePath, 'utf-8')
    const bundle = require('../dist/vue-ssr-server-bundle.json')
    // The client manifests are optional, but it allows the renderer
    // to automatically infer preload/prefetch links and directly add <script>
    // tags for any async chunks used during render, avoiding waterfall requests.
    const clientManifest = require('../dist/vue-ssr-client-manifest.json')
    renderer = createRenderer(bundle, {
      template,
      clientManifest
    })
  } else {
    // In development: setup the dev server with watch and hot-reload,
    // and create a new renderer on bundle / index template update.
    readyPromise = require('../build/dev-server')(
      app,
      templatePath,
      (bundle, options) => {
        renderer = createRenderer(bundle, options)
      }
    )
  }



app.use(async (ctx, next) => {
    console.log(ctx.url);
    if(ctx.path === '/getItem'){
        ctx.status = 200;
        ctx.body = {
            id: ctx.query.id,
            name: '么么哒'
        };
        return;
    }
    if(ctx.path === '/getDetail'){
        ctx.status = 200;
        ctx.body = {
            id: ctx.request.body.id,
            name: '逗你玩'
        };
        return;
    }
    const context = {
        title: 'Vue HN 2.0', // default title
        url: ctx.url
    }
    const render = async () => {
        try{
            let html;
            html = await new Promise((resolve, reject) => {
                renderer.renderToString(context, (err, html) => {
                    if (err) {
                        reject(err);
                    } else {
                        resolve(html);
                    }
                });
            });
            ctx.status = 200;
            ctx.body = html;
        }catch(err){
        }
    }
    if(!isProd){
        // console.log('dev start');
        await readyPromise;
        // console.log('dev end');
    }
    ctx.set("Content-Type", "text/html");
    await render();
   
});


app.listen(port, () => {
    console.log(`app listening ${port}...`);
});
